package pbscheme

import (
	"fmt"
	"github.com/davyxu/protoplus/codegen"
	"github.com/davyxu/protoplus/gen"
	"github.com/davyxu/protoplus/model"
	"path/filepath"
	"sort"
)

const protoDirCodeTemplate = `// Generated by github.com/davyxu/protoplus
// DO NOT EDIT!
syntax = "proto3";

option go_package= "./;{{.PackageName}}";

package {{.PackageName}};

{{range $a, $enumobj := .DependentSource}}
import "{{.}}"; {{end}}

{{range $a, $enumobj := .Enums}}
enum {{.Name}} {	{{range .Fields}}
	{{.Name}} = {{PbTagNumber $enumobj .}}; {{end}}
}{{end}}

{{range $a, $obj := .Structs}}
{{ObjectLeadingComment .}}
message {{.Name}} {	{{range .Fields}}
	{{PbTypeName .}} {{GoFieldName .}} = {{PbTagNumber $obj .}};{{FieldTrailingComment .}} {{end}}
}
{{end}}
`

type PBDescriptorSet struct {
	model.DescriptorSet

	// pb生成文件依赖时, 使用以下字段
	DependentSource []string                    // 按文件管理的描述符取出时, 这个字段有效. 本文件依赖的其他source的symbiol
	SourceName      string                      // 按文件管理的描述符取出时, 这个字段有效. 表示本DescriptorSet的文件名
	dsBySource      map[string]*PBDescriptorSet // 按文件名管理的描述符集合
}

func (self *PBDescriptorSet) addDependentSource(name string) {

	if self.SourceName == name {
		return
	}

	for _, n := range self.DependentSource {
		if n == name {
			return
		}
	}

	self.DependentSource = append(self.DependentSource, name)
}

func (self *PBDescriptorSet) DescriptorSetBySource() map[string]*PBDescriptorSet {
	if self.dsBySource != nil {
		return self.dsBySource
	}

	self.dsBySource = map[string]*PBDescriptorSet{}

	for _, obj := range self.Objects {
		ds := self.dsBySource[obj.SrcName]
		if ds == nil {
			ds = &PBDescriptorSet{}

			ds.PackageName = self.PackageName
			ds.Codec = self.Codec
			ds.SourceName = obj.SrcName

			self.dsBySource[obj.SrcName] = ds
		}

		ds.AddObject(obj)
	}

	for _, file := range self.dsBySource {
		for _, st := range file.Structs() {

			for _, fd := range st.Fields {

				switch fd.Kind {
				case model.Kind_Struct, model.Kind_Enum:
					refTarget := self.ObjectByName(fd.Type)
					if refTarget != nil {
						file.addDependentSource(refTarget.SrcName)
					}
				}
			}
		}
	}

	return self.dsBySource
}

func GenProtoDir(ctx *gen.Context) error {

	rootDS := &PBDescriptorSet{DescriptorSet: *ctx.DescriptorSet}

	//var sb strings.Builder

	var srcNameList []string
	for srcName, ds := range rootDS.DescriptorSetBySource() {

		srcNameList = append(srcNameList, srcName)

		generator := codegen.NewCodeGen("dirproto").
			RegisterTemplateFunc(codegen.UsefulFunc).
			RegisterTemplateFunc(UsefulFunc).
			ParseTemplate(protoDirCodeTemplate, ds)

		if generator.Error() != nil {
			fmt.Println(string(generator.Data()))
			return generator.Error()
		}

		fullPathName := filepath.Join(ctx.OutputFileName, srcName)

		err := generator.WriteOutputFile(fullPathName).Error()
		if err != nil {
			return err
		}
	}

	sort.Strings(srcNameList)

	//for _, d := range srcNameList {
	//	fmt.Fprintf(&sb, "%s ", d)
	//}
	//
	//err := ioutil.WriteFile(filepath.Join(ctx.OutputFileName, "filelist.txt"), []byte(sb.String()), 0666)

	return nil
}
